import {
  require_react
} from "./chunk-FCVBRA66.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/skybridge/dist/web/bridges/apps-sdk/types.js
var TOOL_RESPONSE_EVENT_TYPE = "openai:tool_response";
var SET_GLOBALS_EVENT_TYPE = "openai:set_globals";
var SetGlobalsEvent = class extends CustomEvent {
  type = SET_GLOBALS_EVENT_TYPE;
};

// node_modules/skybridge/dist/web/bridges/apps-sdk/bridge.js
var AppsSdkBridge = class _AppsSdkBridge {
  static instance = null;
  static getInstance() {
    if (window.skybridge.hostType !== "apps-sdk" || window.openai === void 0) {
      throw new Error("Apps SDK Bridge can only be used in the apps-sdk runtime");
    }
    if (_AppsSdkBridge.instance === null) {
      _AppsSdkBridge.instance = new _AppsSdkBridge();
    }
    return _AppsSdkBridge.instance;
  }
  static resetInstance() {
    if (_AppsSdkBridge.instance) {
      _AppsSdkBridge.instance = null;
    }
  }
  subscribe(keyOrKeys) {
    const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];
    return (onChange) => {
      const handleSetGlobal = (event) => {
        const hasRelevantChange = keys.some((key) => event.detail.globals[key] !== void 0);
        if (!hasRelevantChange) {
          return;
        }
        onChange();
      };
      window.addEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal, {
        passive: true
      });
      return () => {
        window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal);
      };
    };
  }
  getSnapshot = (key) => {
    if (window.openai === void 0) {
      throw new Error(`window.openai is not available. Make sure you're calling the hook requiring ${key} within the OpenAI iFrame skybridge runtime.`);
    }
    return window.openai[key];
  };
};

// node_modules/skybridge/dist/web/bridges/apps-sdk/adaptor.js
var AppsSdkAdaptor = class _AppsSdkAdaptor {
  static instance = null;
  static getInstance() {
    if (!_AppsSdkAdaptor.instance) {
      _AppsSdkAdaptor.instance = new _AppsSdkAdaptor();
    }
    return _AppsSdkAdaptor.instance;
  }
  static resetInstance() {
    _AppsSdkAdaptor.instance = null;
  }
  getHostContextStore(key) {
    const bridge = AppsSdkBridge.getInstance();
    return {
      subscribe: bridge.subscribe(key),
      getSnapshot: () => bridge.getSnapshot(key)
    };
  }
  callTool = async (name, args) => {
    return window.openai.callTool(name, args);
  };
  requestDisplayMode = (mode) => {
    return window.openai.requestDisplayMode({ mode });
  };
  sendFollowUpMessage = (prompt) => {
    return window.openai.sendFollowUpMessage({ prompt });
  };
  openExternal(href) {
    window.openai.openExternal({ href });
  }
  setWidgetState = (stateOrUpdater) => {
    const newState = typeof stateOrUpdater === "function" ? stateOrUpdater(window.openai.widgetState) : stateOrUpdater;
    return window.openai.setWidgetState(newState);
  };
  uploadFile = (file) => {
    return window.openai.uploadFile(file);
  };
  getFileDownloadUrl = (file) => {
    return window.openai.getFileDownloadUrl(file);
  };
  openModal(options) {
    return window.openai.requestModal(options);
  }
  setOpenInAppUrl(href) {
    href = href.trim();
    if (!href) {
      throw new Error("The href parameter is required.");
    }
    const serverUrl = window.skybridge.serverUrl;
    if (!serverUrl) {
      throw new Error("The widgetDomain property has not been set on the widget resource meta object.");
    }
    const domainUrl = new URL(serverUrl);
    const hrefUrl = new URL(href, serverUrl);
    if (domainUrl.origin !== hrefUrl.origin) {
      throw new Error("Provided href is not compatible with widget domain: origin differs");
    }
    return window.openai.setOpenInAppUrl({ href });
  }
};

// node_modules/skybridge/dist/web/bridges/apps-sdk/use-apps-sdk-context.js
var import_react = __toESM(require_react(), 1);
function useAppsSdkContext(key) {
  const bridge = AppsSdkBridge.getInstance();
  return (0, import_react.useSyncExternalStore)(bridge.subscribe(key), () => bridge.getSnapshot(key));
}

// node_modules/skybridge/dist/web/bridges/mcp-app/bridge.js
var LATEST_PROTOCOL_VERSION = "2025-11-21";
var JsonRpcErrorCode;
(function(JsonRpcErrorCode2) {
  JsonRpcErrorCode2[JsonRpcErrorCode2["ParseError"] = -32700] = "ParseError";
  JsonRpcErrorCode2[JsonRpcErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  JsonRpcErrorCode2[JsonRpcErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  JsonRpcErrorCode2[JsonRpcErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  JsonRpcErrorCode2[JsonRpcErrorCode2["InternalError"] = -32603] = "InternalError";
})(JsonRpcErrorCode || (JsonRpcErrorCode = {}));
var McpAppBridge = class _McpAppBridge {
  static instance = null;
  context = {
    toolInput: null,
    toolCancelled: null,
    toolResult: null
  };
  listeners = /* @__PURE__ */ new Map();
  pendingRequests = /* @__PURE__ */ new Map();
  nextId = 1;
  initialized;
  appInitializationOptions;
  requestTimeout;
  cleanupSizeObserver = null;
  constructor(options, requestTimeout = 1e4) {
    this.requestTimeout = requestTimeout;
    this.initialized = false;
    this.appInitializationOptions = {
      appInfo: options.appInfo,
      appCapabilities: {},
      protocolVersion: LATEST_PROTOCOL_VERSION
    };
    this.init();
  }
  static getInstance(options, requestTimeout) {
    if (window.skybridge.hostType !== "mcp-app") {
      throw new Error("MCP App Bridge can only be used in the mcp-app runtime");
    }
    if (_McpAppBridge.instance && (options || requestTimeout)) {
      console.warn("McpAppBridge.getInstance: options and requestTimeout ignored, instance already exists");
    }
    if (!_McpAppBridge.instance) {
      const defaultOptions = {
        appInfo: { name: "skybridge-app", version: "0.0.1" }
      };
      _McpAppBridge.instance = new _McpAppBridge({ ...defaultOptions, ...options }, requestTimeout);
    }
    return _McpAppBridge.instance;
  }
  subscribe(keyOrKeys) {
    const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];
    return (onChange) => {
      for (const key of keys) {
        this.listeners.set(key, /* @__PURE__ */ new Set([...this.listeners.get(key) || [], onChange]));
      }
      return () => {
        for (const key of keys) {
          this.listeners.get(key)?.delete(onChange);
        }
      };
    };
  }
  getSnapshot(key) {
    return this.context[key];
  }
  cleanup = () => {
    window.removeEventListener("message", this.handleMessage);
    this.pendingRequests.forEach((request) => {
      clearTimeout(request.timeout);
    });
    this.pendingRequests.clear();
    this.listeners.clear();
    this.cleanupSizeObserver?.();
    this.cleanupSizeObserver = null;
  };
  static resetInstance() {
    if (_McpAppBridge.instance) {
      _McpAppBridge.instance.cleanup();
      _McpAppBridge.instance = null;
    }
  }
  request({ method, params }) {
    const id = this.nextId++;
    const { promise, resolve, reject } = Promise.withResolvers();
    this.pendingRequests.set(id, {
      resolve,
      reject,
      timeout: setTimeout(() => {
        reject(new Error("Request timed out"));
        this.pendingRequests.delete(id);
      }, this.requestTimeout)
    });
    window.parent.postMessage({ jsonrpc: "2.0", id, method, params }, "*");
    return promise;
  }
  emit(key) {
    this.listeners.get(key)?.forEach((listener) => {
      listener();
    });
  }
  updateContext(context) {
    this.context = { ...this.context, ...context };
    for (const key of Object.keys(context)) {
      this.emit(key);
    }
  }
  init() {
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    if (typeof window === "undefined" || window.parent === window) {
      return;
    }
    window.addEventListener("message", this.handleMessage);
    this.connect();
  }
  handleMessage = (event) => {
    const data = event.data;
    if (data.jsonrpc !== "2.0") {
      return;
    }
    if ("id" in data) {
      if ("method" in data) {
        this.handleRequest(data);
        return;
      }
      this.handleResponse(data);
      return;
    }
    this.handleNotification(data);
  };
  handleResponse(response) {
    const request = this.pendingRequests.get(response.id);
    if (request) {
      clearTimeout(request.timeout);
      this.pendingRequests.delete(response.id);
      if ("error" in response) {
        request.reject(new Error(response.error.message));
        return;
      }
      request.resolve(response.result);
    }
  }
  handleNotification = (notification) => {
    switch (notification.method) {
      case "ui/notifications/host-context-changed":
        this.updateContext(notification.params);
        return;
      case "ui/notifications/tool-input":
        this.updateContext({
          toolInput: notification.params.arguments ?? {}
        });
        return;
      case "ui/notifications/tool-result":
        this.updateContext({
          toolResult: notification.params
        });
        return;
      case "ui/notifications/tool-cancelled":
        this.updateContext({
          toolCancelled: notification.params
        });
        return;
    }
  };
  handleRequest = (request) => {
    switch (request.method) {
      case "ui/resource-teardown":
        this.cleanup();
        window.parent.postMessage({
          jsonrpc: "2.0",
          id: request.id,
          result: {}
        }, "*");
        return;
      default:
        window.parent.postMessage({
          jsonrpc: "2.0",
          id: request.id,
          error: {
            code: JsonRpcErrorCode.MethodNotFound,
            message: "Unsupported Request"
          }
        }, "*");
    }
  };
  async connect() {
    try {
      const result = await this.request({
        method: "ui/initialize",
        params: this.appInitializationOptions
      });
      this.updateContext(result.hostContext);
      this.notify({ method: "ui/notifications/initialized" });
      this.cleanupSizeObserver = this.setupSizeChangedNotifications();
    } catch (err) {
      console.error(err);
    }
  }
  notify(notification) {
    window.parent.postMessage({ jsonrpc: "2.0", ...notification }, "*");
  }
  sendSizeChanged(params) {
    this.notify({ method: "ui/notifications/size-changed", params });
  }
  /**
   * Set up automatic size change notifications using ResizeObserver.
   * Based on @modelcontextprotocol/ext-apps App.setupSizeChangedNotifications
   * @see https://github.com/modelcontextprotocol/ext-apps/blob/main/src/app.ts#L940-L989
   */
  setupSizeChangedNotifications() {
    let scheduled = false;
    let lastWidth = 0;
    let lastHeight = 0;
    const sendBodySizeChanged = () => {
      if (scheduled) {
        return;
      }
      scheduled = true;
      requestAnimationFrame(() => {
        scheduled = false;
        let width;
        let height;
        if (this.context.displayMode === "fullscreen") {
          width = window.innerWidth;
          height = window.innerHeight;
        } else {
          const body = document.body;
          width = Math.ceil(body.scrollWidth);
          height = Math.ceil(body.scrollHeight);
        }
        if (width !== lastWidth || height !== lastHeight) {
          lastWidth = width;
          lastHeight = height;
          this.sendSizeChanged({ width, height });
        }
      });
    };
    sendBodySizeChanged();
    const resizeObserver = new ResizeObserver(sendBodySizeChanged);
    resizeObserver.observe(document.documentElement);
    resizeObserver.observe(document.body);
    return () => resizeObserver.disconnect();
  }
};

// node_modules/dequal/lite/index.mjs
var has = Object.prototype.hasOwnProperty;
function dequal(foo, bar) {
  var ctor, len;
  if (foo === bar) return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len])) ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/skybridge/dist/web/bridges/mcp-app/adaptor.js
var McpAppAdaptor = class _McpAppAdaptor {
  static instance = null;
  stores;
  _widgetState = null;
  widgetStateListeners = /* @__PURE__ */ new Set();
  _viewState = {
    mode: "inline"
  };
  viewListeners = /* @__PURE__ */ new Set();
  constructor() {
    this.stores = this.initializeStores();
  }
  static getInstance() {
    if (!_McpAppAdaptor.instance) {
      _McpAppAdaptor.instance = new _McpAppAdaptor();
    }
    return _McpAppAdaptor.instance;
  }
  static resetInstance() {
    _McpAppAdaptor.instance = null;
  }
  getHostContextStore(key) {
    return this.stores[key];
  }
  callTool = async (name, args) => {
    const bridge = McpAppBridge.getInstance();
    const response = await bridge.request({
      method: "tools/call",
      params: {
        name,
        arguments: args ?? void 0
      }
    });
    const result = response.content.filter((content) => content.type === "text").map(({ text }) => text).join("\n");
    return {
      content: response.content,
      structuredContent: response.structuredContent ?? {},
      isError: response.isError ?? false,
      result,
      meta: response._meta ?? {}
    };
  };
  requestDisplayMode = (mode) => {
    const bridge = McpAppBridge.getInstance();
    if (mode !== "modal") {
      return bridge.request({
        method: "ui/request-display-mode",
        params: { mode }
      });
    }
    throw new Error("Modal display mode is not accessible in MCP App.");
  };
  sendFollowUpMessage = async (prompt) => {
    const bridge = McpAppBridge.getInstance();
    await bridge.request({
      method: "ui/message",
      params: {
        role: "user",
        content: [
          {
            type: "text",
            text: prompt
          }
        ]
      }
    });
  };
  openExternal(href) {
    const bridge = McpAppBridge.getInstance();
    bridge.request({
      method: "ui/open-link",
      params: { url: href }
    });
  }
  initializeStores() {
    return {
      theme: this.createHostContextStore(["theme"], ({ theme }) => theme ?? "light"),
      locale: this.createHostContextStore(["locale"], ({ locale }) => locale ?? "en-US"),
      safeArea: this.createHostContextStore(["safeAreaInsets"], ({ safeAreaInsets }) => ({
        insets: safeAreaInsets ?? { top: 0, right: 0, bottom: 0, left: 0 }
      })),
      displayMode: this.createHostContextStore(["displayMode"], ({ displayMode }) => displayMode ?? "inline"),
      maxHeight: this.createHostContextStore(["containerDimensions"], ({ containerDimensions }) => {
        if (containerDimensions && "maxHeight" in containerDimensions) {
          return containerDimensions.maxHeight;
        }
        return void 0;
      }),
      userAgent: this.createHostContextStore(["platform", "deviceCapabilities"], ({ platform, deviceCapabilities }) => ({
        device: {
          type: platform === "web" ? "desktop" : platform ?? "unknown"
        },
        capabilities: {
          hover: true,
          touch: true,
          ...deviceCapabilities
        }
      })),
      toolInput: this.createHostContextStore(["toolInput"], ({ toolInput }) => toolInput ?? null),
      toolOutput: this.createHostContextStore(["toolResult"], ({ toolResult }) => toolResult?.structuredContent ?? null),
      toolResponseMetadata: this.createHostContextStore(["toolResult"], ({ toolResult }) => toolResult?._meta ?? null),
      view: {
        subscribe: (onChange) => {
          this.viewListeners.add(onChange);
          return () => {
            this.viewListeners.delete(onChange);
          };
        },
        getSnapshot: () => this._viewState
      },
      widgetState: {
        subscribe: (onChange) => {
          this.widgetStateListeners.add(onChange);
          return () => {
            this.widgetStateListeners.delete(onChange);
          };
        },
        getSnapshot: () => this._widgetState
      }
    };
  }
  setWidgetState = async (stateOrUpdater) => {
    const newState = typeof stateOrUpdater === "function" ? stateOrUpdater(this._widgetState) : stateOrUpdater;
    const bridge = McpAppBridge.getInstance();
    await bridge.request({
      method: "ui/update-model-context",
      params: {
        structuredContent: newState,
        content: [{ type: "text", text: JSON.stringify(newState) }]
      }
    });
    this._widgetState = newState;
    this.widgetStateListeners.forEach((listener) => {
      listener();
    });
  };
  /**
   * @throws File upload is not supported in MCP App.
   */
  uploadFile() {
    throw new Error("File upload is not supported in MCP App.");
  }
  /**
   * @throws File download is not supported in MCP App.
   */
  getFileDownloadUrl() {
    throw new Error("File download is not supported in MCP App.");
  }
  openModal(options) {
    this._viewState = { mode: "modal", params: options.params };
    this.viewListeners.forEach((listener) => {
      listener();
    });
  }
  closeModal() {
    this._viewState = { mode: "inline" };
    this.viewListeners.forEach((listener) => {
      listener();
    });
  }
  setOpenInAppUrl(_href) {
    throw new Error("setOpenInAppUrl is not implemented in MCP App.");
  }
  createHostContextStore(keys, computeSnapshot) {
    const bridge = McpAppBridge.getInstance();
    let cachedValue;
    return {
      subscribe: bridge.subscribe(keys),
      getSnapshot: () => {
        const context = Object.fromEntries(keys.map((k) => [k, bridge.getSnapshot(k)]));
        const newValue = computeSnapshot(context);
        if (cachedValue !== void 0 && dequal(cachedValue, newValue)) {
          return cachedValue;
        }
        cachedValue = newValue;
        return newValue;
      }
    };
  }
};

// node_modules/skybridge/dist/web/bridges/get-adaptor.js
var getAdaptor = () => {
  return window.skybridge.hostType === "apps-sdk" ? AppsSdkAdaptor.getInstance() : McpAppAdaptor.getInstance();
};

// node_modules/skybridge/dist/web/bridges/mcp-app/use-mcp-app-context.js
var import_react2 = __toESM(require_react(), 1);
function useMcpAppContext(key, options, requestTimeout) {
  const bridge = McpAppBridge.getInstance(options, requestTimeout);
  return (0, import_react2.useSyncExternalStore)(bridge.subscribe(key), () => bridge.getSnapshot(key));
}

// node_modules/skybridge/dist/web/bridges/use-host-context.js
var import_react3 = __toESM(require_react(), 1);
var useHostContext = (key) => {
  const adaptor = getAdaptor();
  const store = adaptor.getHostContextStore(key);
  return (0, import_react3.useSyncExternalStore)(store.subscribe, store.getSnapshot);
};

export {
  TOOL_RESPONSE_EVENT_TYPE,
  SET_GLOBALS_EVENT_TYPE,
  SetGlobalsEvent,
  AppsSdkBridge,
  AppsSdkAdaptor,
  useAppsSdkContext,
  McpAppBridge,
  McpAppAdaptor,
  getAdaptor,
  useMcpAppContext,
  useHostContext
};
//# sourceMappingURL=chunk-7RVYFRNE.js.map
