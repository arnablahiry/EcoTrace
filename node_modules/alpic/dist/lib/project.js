import * as p from "@clack/prompts";
import chalk from "chalk";
import { existsSync, readFileSync, statSync } from "node:fs";
import { resolve } from "node:path";
import { api } from "../api.js";
import { config } from "./config.js";
export function resolveDeployDir(raw) {
    const dir = resolve((raw ?? "").trim() || process.cwd());
    if (!existsSync(dir)) {
        throw new Error(`Path does not exist: ${dir}`);
    }
    if (!statSync(dir).isDirectory()) {
        throw new Error(`Path is not a directory: ${dir}`);
    }
    return dir;
}
export async function confirmDeployWithExistingConfig(existingConfig) {
    const envLabel = existingConfig.environmentName ? ` to environment "${existingConfig.environmentName}"` : "";
    const confirm = await p.confirm({
        message: chalk.bold(`Deploy project "${existingConfig.projectName}"${envLabel}?`),
        initialValue: true,
    });
    if (p.isCancel(confirm))
        return null;
    return confirm === true;
}
export async function selectEnvironmentFromList(environments) {
    if (environments.length === 0) {
        return null;
    }
    const choice = await p.select({
        message: chalk.bold("Choose an environment to deploy to"),
        options: environments.map((env) => ({
            value: env.id,
            label: env.sourceBranch ? `${env.name} (${env.sourceBranch})` : env.name,
        })),
    });
    if (p.isCancel(choice))
        return null;
    const environment = environments.find((e) => e.id === choice);
    return environment ?? null;
}
export async function confirmDeployDirectory(deployDir) {
    const confirm = await p.confirm({
        message: chalk.bold(`Deploy the directory? `) + chalk.cyan(deployDir),
        initialValue: true,
    });
    if (p.isCancel(confirm))
        return false;
    return confirm === true;
}
export async function confirmLinkExisting() {
    const link = await p.confirm({
        message: chalk.bold("Link to existing project?"),
        initialValue: true,
    });
    if (p.isCancel(link))
        return false;
    return link === true;
}
export async function confirmLinkToAnotherProject() {
    const link = await p.confirm({
        message: chalk.bold("Link to another project?"),
        initialValue: true,
    });
    if (p.isCancel(link))
        return false;
    return link === true;
}
export async function selectProjectFromList(projects) {
    if (projects.length === 0) {
        return null;
    }
    const choice = await p.select({
        message: chalk.bold("Choose a project"),
        options: projects.map((proj) => ({ value: proj.id, label: proj.name })),
    });
    if (p.isCancel(choice))
        return null;
    const project = projects.find((proj) => proj.id === choice);
    return project ?? null;
}
export async function promptRootDirectory(deployDir) {
    while (true) {
        const rootDir = await p.text({
            message: chalk.bold("Root directory"),
            placeholder: ".",
            initialValue: ".",
            validate: (value) => {
                if (value != null && value.length > 512)
                    return "Path must be at most 512 characters.";
                return undefined;
            },
        });
        if (p.isCancel(rootDir))
            return null;
        const trimmed = rootDir.trim();
        if (trimmed === "" || trimmed === ".")
            return undefined;
        const resolved = resolve(deployDir, trimmed);
        if (!existsSync(resolved)) {
            p.log.error(`Path does not exist: ${resolved}`);
            continue;
        }
        if (!statSync(resolved).isDirectory()) {
            p.log.error(`Path is not a directory: ${resolved}`);
            continue;
        }
        return trimmed;
    }
}
async function resolveEnvironmentForProject(projectId) {
    const project = await api.getProject(projectId);
    const environments = project.environments ?? [];
    if (environments.length === 0) {
        throw new Error("No environments found for this project.");
    }
    const environment = await selectEnvironmentFromList(environments);
    if (!environment)
        return null;
    return { environmentId: environment.id, environmentName: environment.name };
}
export async function resolveProjectForDeploy(deployDir) {
    const ok = await confirmDeployDirectory(deployDir);
    if (!ok)
        return null;
    const existingConfig = config.load(deployDir);
    if (existingConfig) {
        let confirm;
        while (true) {
            confirm = await confirmDeployWithExistingConfig(existingConfig);
            if (confirm === null)
                return null;
            if (confirm)
                break;
            const linkAnother = await confirmLinkToAnotherProject();
            if (p.isCancel(linkAnother))
                return null;
            if (linkAnother) {
                const linkExisting = await confirmLinkExisting();
                if (!linkExisting) {
                    return runCreateProjectFlow(deployDir);
                }
                return runLinkingFlow(deployDir);
            }
        }
        if (existingConfig.environmentId) {
            return {
                projectId: existingConfig.projectId,
                teamId: existingConfig.teamId,
                projectName: existingConfig.projectName,
                environmentId: existingConfig.environmentId,
                environmentName: existingConfig.environmentName,
            };
        }
        const env = await resolveEnvironmentForProject(existingConfig.projectId);
        if (!env)
            return null;
        const updatedConfig = {
            ...existingConfig,
            environmentId: env.environmentId,
            environmentName: env.environmentName,
        };
        config.save(updatedConfig, deployDir);
        p.note(`Environment "${env.environmentName}" will be used for future deploys.`);
        return updatedConfig;
    }
    const linkExisting = await confirmLinkExisting();
    if (!linkExisting) {
        return runCreateProjectFlow(deployDir);
    }
    return runLinkingFlow(deployDir);
}
async function runCreateProjectFlow(deployDir) {
    const name = await p.text({
        message: chalk.bold("Project name"),
        placeholder: "my-app",
        validate: (value) => {
            if (!value?.trim())
                return "Project name is required.";
            if (value.length > 100)
                return "Project name must be at most 100 characters.";
            return undefined;
        },
    });
    if (p.isCancel(name))
        return null;
    const detectedRuntime = detectRuntime(deployDir);
    const runtime = await p.select({
        message: chalk.bold("Runtime"),
        options: [
            { value: "node24", label: "Node.js 24" },
            { value: "node22", label: "Node.js 22" },
            { value: "python3.14", label: "Python 3.14" },
            { value: "python3.13", label: "Python 3.13" },
        ],
        initialValue: detectedRuntime ?? "node24",
    });
    if (p.isCancel(runtime))
        return null;
    const rootDirectory = await promptRootDirectory(deployDir);
    const spin = p.spinner();
    spin.start("Creating project...");
    try {
        const projectInput = {
            name: name.trim(),
            runtime,
        };
        if (rootDirectory) {
            projectInput.rootDirectory = rootDirectory;
        }
        const created = await api.createProject(projectInput);
        spin.stop("Project created.");
        const productionEnv = created.productionEnvironment;
        if (!productionEnv) {
            throw new Error("Project was created but has no Production environment.");
        }
        const newConfig = {
            projectId: created.id,
            teamId: created.teamId,
            projectName: created.name,
            environmentId: productionEnv.id,
            environmentName: productionEnv.name,
        };
        config.save(newConfig, deployDir);
        return newConfig;
    }
    catch (error) {
        spin.stop();
        throw error;
    }
}
async function runLinkingFlow(deployDir) {
    const projects = await api.listProjects();
    if (projects.length === 0) {
        throw new Error("No projects found. Create a project in the Alpic dashboard first.");
    }
    const project = await selectProjectFromList(projects);
    if (!project)
        return null;
    const environments = project.environments ?? [];
    if (environments.length === 0) {
        throw new Error("No environments found for this project.");
    }
    const environment = await selectEnvironmentFromList(environments);
    if (!environment)
        return null;
    const newConfig = {
        projectId: project.id,
        teamId: project.teamId,
        projectName: project.name,
        environmentId: environment.id,
        environmentName: environment.name,
    };
    config.save(newConfig, deployDir);
    p.note(`Linked to project "${project.name}", environment "${environment.name}".`);
    return newConfig;
}
function detectRuntime(dir) {
    const has = (file) => existsSync(resolve(dir, file));
    const read = (file) => {
        try {
            return readFileSync(resolve(dir, file), "utf8");
        }
        catch {
            return "";
        }
    };
    if (has("pyproject.toml") || has("requirements.txt") || has("setup.py") || has(".python-version")) {
        return "python3.13";
    }
    if (has("package.json")) {
        const nvmrc = has(".nvmrc") ? (read(".nvmrc").trim().split(/\s/)[0] ?? "") : "";
        const major = nvmrc.replace(/^v/i, "").match(/^(\d+)/)?.[1];
        if (major === "22")
            return "node22";
        return "node24";
    }
    return null;
}
//# sourceMappingURL=project.js.map