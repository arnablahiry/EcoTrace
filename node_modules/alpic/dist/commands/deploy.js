import * as p from "@clack/prompts";
import { Args, Command } from "@oclif/core";
import chalk from "chalk";
import { readFileSync, rmSync } from "node:fs";
import { api, getFrontendBaseUrl } from "../api.js";
import { createTarArchive, getFilesToPack } from "../lib/archive.js";
import { deployAndWait, formatElapsed } from "../lib/deployment.js";
import { resolveDeployDir, resolveProjectForDeploy } from "../lib/project.js";
import { uploadToPresignedUrl } from "../lib/upload.js";
export class Deploy extends Command {
    static description = "Deploy a project to Alpic";
    static examples = ["<%= config.bin %> deploy", "<%= config.bin %> deploy ./my-app"];
    static args = {
        directory: Args.string({
            description: "Directory to deploy (default: current directory)",
            required: false,
        }),
    };
    async run() {
        const { args } = await this.parse(Deploy);
        p.intro("Deploying to Alpic");
        const apiKey = process.env.ALPIC_API_KEY;
        if (!apiKey) {
            p.cancel("ALPIC_API_KEY environment variable is required. Get your API key from Team settings in the Alpic dashboard.");
            this.exit(1);
            return;
        }
        const deployDir = resolveDeployDir(args.directory);
        const config = await resolveProjectForDeploy(deployDir);
        if (!config) {
            p.cancel("Deploy cancelled");
            this.exit(1);
            return;
        }
        const spinner = p.spinner();
        let tmpDir;
        try {
            spinner.start("Collecting source files...");
            const files = getFilesToPack(deployDir);
            spinner.stop(`Collected ${files.length} file${files.length === 1 ? "" : "s"}`);
            const result = await createTarArchive(files, deployDir);
            tmpDir = result.tmpDir;
            const archivePath = result.archivePath;
            const { uploadUrl, token } = await api.getPresignedUploadUrl();
            spinner.start("Uploading source...");
            const buffer = readFileSync(archivePath);
            await uploadToPresignedUrl(uploadUrl, buffer);
            spinner.stop("Upload complete");
            spinner.start("Triggering deployment...");
            const deployStartedAt = Date.now();
            const initialDeployment = await api.deployEnvironment(config.environmentId, { token });
            spinner.stop("Deployment started");
            const { deployment, elapsedMs } = await deployAndWait({
                initial: initialDeployment,
                startedAt: deployStartedAt,
                teamId: config.teamId,
                projectId: config.projectId,
            });
            const elapsedStr = formatElapsed(elapsedMs);
            if (deployment.status !== "deployed") {
                throw new Error("Deployment failed");
            }
            const environment = await api.getEnvironment(config.environmentId);
            const urls = environment.mcpServerUrl ? [environment.mcpServerUrl] : environment.domains;
            p.box([...urls.map((url) => chalk.bold(`ðŸ”— ${url}`)), "", `Completed in ${elapsedStr}`].join("\n"), "Deployment summary:", {
                contentAlign: "center",
                titleAlign: "center",
                width: "auto",
                rounded: true,
                contentPadding: 3,
            });
        }
        catch (error) {
            spinner.stop();
            const message = error instanceof Error ? error.message : String(error);
            p.cancel(`Error: ${message}`);
            this.exit(1);
        }
        finally {
            if (tmpDir) {
                rmSync(tmpDir, { recursive: true, force: true });
            }
        }
    }
}
//# sourceMappingURL=deploy.js.map