import type { McpUiResourceMeta } from "@modelcontextprotocol/ext-apps";
import { McpServer as McpServerBase, type RegisteredTool } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { AnySchema, SchemaOutput, ZodRawShapeCompat } from "@modelcontextprotocol/sdk/server/zod-compat.js";
import type { RequestHandlerExtra } from "@modelcontextprotocol/sdk/shared/protocol.js";
import type { CallToolResult, Resource, ServerNotification, ServerRequest, ToolAnnotations } from "@modelcontextprotocol/sdk/types.js";
export type ToolDef<TInput = unknown, TOutput = unknown, TResponseMetadata = unknown> = {
    input: TInput;
    output: TOutput;
    responseMetadata: TResponseMetadata;
};
/**
 * Extended MCP Apps CSP with upcoming fields from ext-apps PR #158
 * and Skybridge-specific fields for OpenAI compatibility
 * @see https://github.com/modelcontextprotocol/ext-apps/pull/158
 */
type ExtendedMcpUiResourceCsp = McpUiResourceMeta["csp"] & {
    /**
     * Origins that can receive openExternal redirects without safe-link modal (OpenAI-specific)
     * @see https://developers.openai.com/apps-sdk/reference#component-resource-_meta-fields
     */
    redirectDomains?: string[];
};
/** Extended MCP Apps resource metadata with upcoming CSP fields */
type ExtendedMcpUiResourceMeta = Omit<McpUiResourceMeta, "csp"> & {
    csp?: ExtendedMcpUiResourceCsp;
};
/** User-provided resource configuration with optional CSP override */
export type WidgetResourceMeta = {
    ui?: ExtendedMcpUiResourceMeta;
} & Resource["_meta"];
export type WidgetHostType = "apps-sdk" | "mcp-app";
type McpServerOriginalResourceConfig = Omit<Resource, "uri" | "name" | "mimeType" | "_meta"> & {
    _meta?: WidgetResourceMeta;
    /** Restrict host types to a specific subset */
    hosts?: WidgetHostType[];
};
type McpServerOriginalToolConfig = Omit<Parameters<typeof McpServerBase.prototype.registerTool<ZodRawShapeCompat, ZodRawShapeCompat>>[1], "inputSchema" | "outputSchema">;
type Simplify<T> = {
    [K in keyof T]: T[K];
};
type ExtractStructuredContent<T> = T extends {
    structuredContent: infer SC;
} ? Simplify<SC> : never;
type ExtractMeta<T> = [Extract<T, {
    _meta: unknown;
}>] extends [never] ? unknown : Extract<T, {
    _meta: unknown;
}> extends {
    _meta: infer M;
} ? Simplify<M> : unknown;
/**
 * Type-level marker interface for cross-package type inference.
 * This enables TypeScript to infer tool types across package boundaries
 * using structural typing on the $types property, rather than relying on
 * class generic inference which fails when McpServer comes from different
 * package installations.
 *
 * Inspired by tRPC's _def pattern and Hono's type markers.
 */
export interface McpServerTypes<TTools extends Record<string, ToolDef>> {
    readonly tools: TTools;
}
type ShapeOutput<Shape extends ZodRawShapeCompat> = Simplify<{
    [K in keyof Shape as undefined extends SchemaOutput<Shape[K]> ? never : K]: SchemaOutput<Shape[K]>;
} & {
    [K in keyof Shape as undefined extends SchemaOutput<Shape[K]> ? K : never]?: SchemaOutput<Shape[K]>;
}>;
type AddTool<TTools, TName extends string, TInput extends ZodRawShapeCompat, TOutput, TResponseMetadata = unknown> = McpServer<TTools & {
    [K in TName]: ToolDef<ShapeOutput<TInput>, TOutput, TResponseMetadata>;
}>;
type ToolConfig<TInput extends ZodRawShapeCompat | AnySchema> = {
    title?: string;
    description?: string;
    inputSchema?: TInput;
    outputSchema?: ZodRawShapeCompat | AnySchema;
    annotations?: ToolAnnotations;
    _meta?: Record<string, unknown>;
};
type ToolHandler<TInput extends ZodRawShapeCompat, TReturn extends {
    content: CallToolResult["content"];
} = CallToolResult> = (args: ShapeOutput<TInput>, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => TReturn | Promise<TReturn>;
export declare class McpServer<TTools extends Record<string, ToolDef> = Record<never, ToolDef>> extends McpServerBase {
    readonly $types: McpServerTypes<TTools>;
    registerWidget<TName extends string, TInput extends ZodRawShapeCompat, TReturn extends {
        content: CallToolResult["content"];
    }>(name: TName, resourceConfig: McpServerOriginalResourceConfig, toolConfig: McpServerOriginalToolConfig & {
        inputSchema?: TInput;
        outputSchema?: ZodRawShapeCompat | AnySchema;
    }, toolCallback: ToolHandler<TInput, TReturn>): AddTool<TTools, TName, TInput, ExtractStructuredContent<TReturn>, ExtractMeta<TReturn>>;
    registerTool<TName extends string, InputArgs extends ZodRawShapeCompat, TReturn extends {
        content: CallToolResult["content"];
    }>(name: TName, config: ToolConfig<InputArgs>, cb: ToolHandler<InputArgs, TReturn>): AddTool<TTools, TName, InputArgs, ExtractStructuredContent<TReturn>, ExtractMeta<TReturn>>;
    registerTool<InputArgs extends ZodRawShapeCompat>(name: string, config: ToolConfig<InputArgs>, cb: ToolHandler<InputArgs>): RegisteredTool;
    private registerWidgetResource;
    private lookupDistFile;
    private lookupDistFileWithIndexFallback;
    private readManifest;
}
export {};
