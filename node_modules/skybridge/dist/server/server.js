import crypto from "node:crypto";
import { readFileSync } from "node:fs";
import path from "node:path";
import { McpServer as McpServerBase, } from "@modelcontextprotocol/sdk/server/mcp.js";
import { mergeWith, union } from "es-toolkit";
import { templateHelper } from "./templateHelper.js";
const mergeWithUnion = (target, source) => {
    return mergeWith(target, source, (targetVal, sourceVal) => {
        if (Array.isArray(targetVal) && Array.isArray(sourceVal)) {
            return union(targetVal, sourceVal);
        }
    });
};
export class McpServer extends McpServerBase {
    registerWidget(name, resourceConfig, toolConfig, toolCallback) {
        const userMeta = resourceConfig._meta;
        const toolMeta = {
            ...toolConfig._meta,
        };
        if (!resourceConfig.hosts || resourceConfig.hosts.includes("apps-sdk")) {
            const widgetConfig = {
                hostType: "apps-sdk",
                uri: `ui://widgets/apps-sdk/${name}.html`,
                mimeType: "text/html+skybridge",
                buildContentMeta: ({ resourceDomains, connectDomains, domain }) => {
                    const userUi = userMeta?.ui;
                    const userCsp = userUi?.csp;
                    const defaults = {
                        "openai/widgetCSP": {
                            resource_domains: resourceDomains,
                            connect_domains: connectDomains,
                        },
                        "openai/widgetDomain": domain,
                        "openai/widgetDescription": toolConfig.description,
                    };
                    const fromUi = {
                        "openai/widgetCSP": {
                            resource_domains: userCsp?.resourceDomains,
                            connect_domains: userCsp?.connectDomains,
                            frame_domains: userCsp?.frameDomains,
                            redirect_domains: userCsp?.redirectDomains,
                        },
                        "openai/widgetDomain": userUi?.domain,
                        "openai/widgetPrefersBorder": userUi?.prefersBorder,
                    };
                    const directOpenaiKeys = Object.fromEntries(Object.entries(userMeta ?? {}).filter(([key]) => key.startsWith("openai/")));
                    return mergeWithUnion(mergeWithUnion(defaults, fromUi), directOpenaiKeys);
                },
            };
            this.registerWidgetResource({
                name,
                widgetConfig,
                resourceConfig,
            });
            toolMeta["openai/outputTemplate"] = widgetConfig.uri;
        }
        if (!resourceConfig.hosts || resourceConfig.hosts.includes("mcp-app")) {
            const widgetConfig = {
                hostType: "mcp-app",
                uri: `ui://widgets/ext-apps/${name}.html`,
                mimeType: "text/html;profile=mcp-app",
                buildContentMeta: ({ resourceDomains, connectDomains, domain }) => {
                    const defaults = {
                        ui: {
                            csp: {
                                resourceDomains,
                                connectDomains,
                            },
                            domain,
                        },
                    };
                    return mergeWithUnion(defaults, { ui: userMeta?.ui });
                },
            };
            this.registerWidgetResource({
                name,
                widgetConfig,
                resourceConfig,
            });
            // @ts-expect-error - For backwards compatibility with Claude current implementation of the specs
            toolMeta["ui/resourceUri"] = widgetConfig.uri;
            toolMeta.ui = { resourceUri: widgetConfig.uri };
        }
        this.registerTool(name, {
            ...toolConfig,
            _meta: toolMeta,
        }, toolCallback);
        return this;
    }
    registerTool(name, config, cb) {
        super.registerTool(name, config, cb);
        return this;
    }
    registerWidgetResource({ name, widgetConfig, resourceConfig, }) {
        const { hostType, uri: widgetUri, mimeType, buildContentMeta, } = widgetConfig;
        this.registerResource(name, widgetUri, { ...resourceConfig, _meta: resourceConfig._meta }, async (uri, extra) => {
            const isProduction = process.env.NODE_ENV === "production";
            const useForwardedHost = process.env.SKYBRIDGE_USE_FORWARDED_HOST === "true";
            const isClaude = extra?.requestInfo?.headers?.["user-agent"] === "Claude-User";
            const hostFromHeaders = extra?.requestInfo?.headers?.["x-forwarded-host"] ??
                extra?.requestInfo?.headers?.host;
            const useExternalHost = isProduction || useForwardedHost || isClaude;
            const serverUrl = useExternalHost
                ? `https://${hostFromHeaders}`
                : "http://localhost:3000";
            const html = isProduction
                ? templateHelper.renderProduction({
                    hostType,
                    serverUrl,
                    widgetFile: this.lookupDistFileWithIndexFallback(`src/widgets/${name}`),
                    styleFile: this.lookupDistFile("style.css"),
                })
                : templateHelper.renderDevelopment({
                    hostType,
                    serverUrl,
                    useLocalNetworkAccess: !useExternalHost,
                    widgetName: name,
                });
            const VITE_HMR_WEBSOCKET_DEFAULT_URL = "ws://localhost:24678";
            const contentMeta = buildContentMeta({
                resourceDomains: [serverUrl],
                connectDomains: !isProduction ? [VITE_HMR_WEBSOCKET_DEFAULT_URL] : [],
                domain: isClaude
                    ? `${crypto
                        .createHash("sha256")
                        .update(`https://${hostFromHeaders}/mcp`)
                        .digest("hex")
                        .slice(0, 32)}.claudemcpcontent.com`
                    : serverUrl,
                baseUriDomains: [serverUrl],
            });
            return {
                contents: [
                    { uri: uri.href, mimeType, text: html, _meta: contentMeta },
                ],
            };
        });
    }
    lookupDistFile(key) {
        const manifest = this.readManifest();
        return manifest[key]?.file;
    }
    lookupDistFileWithIndexFallback(basePath) {
        const manifest = this.readManifest();
        const flatFileKey = `${basePath}.tsx`;
        const indexFileKey = `${basePath}/index.tsx`;
        return manifest[flatFileKey]?.file ?? manifest[indexFileKey]?.file;
    }
    readManifest() {
        return JSON.parse(readFileSync(path.join(process.cwd(), "dist", "assets", ".vite", "manifest.json"), "utf-8"));
    }
}
//# sourceMappingURL=server.js.map