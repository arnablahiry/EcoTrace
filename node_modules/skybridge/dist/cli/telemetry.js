import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { homedir } from "node:os";
import { join } from "node:path";
import ci from "ci-info";
import { PostHog } from "posthog-node";
const POSTHOG_API_KEY = "phc_rQdkCYr0DO4NcZBQXZnUwsHAbau9zuNwKIpil9FQP6v";
const POSTHOG_HOST = "https://us.i.posthog.com";
const ENV_TELEMETRY_DISABLED = "SKYBRIDGE_TELEMETRY_DISABLED";
const ENV_TELEMETRY_DEBUG = "SKYBRIDGE_TELEMETRY_DEBUG";
const ENV_DO_NOT_TRACK = "DO_NOT_TRACK";
const GLOBAL_CONFIG_DIR = join(homedir(), ".skybridge");
const GLOBAL_CONFIG_FILE = join(GLOBAL_CONFIG_DIR, "config.json");
let posthogClient = null;
function getPostHogClient() {
    if (!posthogClient) {
        posthogClient = new PostHog(POSTHOG_API_KEY, {
            host: POSTHOG_HOST,
            flushAt: 1,
            flushInterval: 0,
        });
    }
    return posthogClient;
}
function readJsonFile(filePath) {
    try {
        if (existsSync(filePath)) {
            const content = readFileSync(filePath, "utf-8");
            return JSON.parse(content);
        }
    }
    catch {
        // Ignore errors reading config
    }
    return null;
}
function writeJsonFile(filePath, data) {
    try {
        const dir = join(filePath, "..");
        if (!existsSync(dir)) {
            mkdirSync(dir, { recursive: true });
        }
        writeFileSync(filePath, JSON.stringify(data, null, 2), "utf-8");
    }
    catch {
        // Ignore errors writing config
    }
}
function getGlobalConfig() {
    const existing = readJsonFile(GLOBAL_CONFIG_FILE);
    if (existing?.machineId && existing?.telemetry !== undefined) {
        return existing;
    }
    const config = {
        machineId: existing?.machineId || crypto.randomUUID(),
        telemetry: {
            enabled: existing?.telemetry?.enabled ?? true,
        },
    };
    writeJsonFile(GLOBAL_CONFIG_FILE, config);
    return config;
}
export function isEnabled() {
    if (process.env[ENV_TELEMETRY_DISABLED] === "1" ||
        process.env[ENV_TELEMETRY_DISABLED]?.toLowerCase() === "true") {
        return false;
    }
    if (process.env[ENV_DO_NOT_TRACK] === "1" ||
        process.env[ENV_DO_NOT_TRACK]?.toLowerCase() === "true") {
        return false;
    }
    if (ci.isCI) {
        return true;
    }
    const config = getGlobalConfig();
    return config.telemetry.enabled;
}
export function isDebugMode() {
    return (process.env[ENV_TELEMETRY_DEBUG] === "1" ||
        process.env[ENV_TELEMETRY_DEBUG]?.toLowerCase() === "true");
}
export function setEnabled(enabled) {
    const config = getGlobalConfig();
    config.telemetry.enabled = enabled;
    writeJsonFile(GLOBAL_CONFIG_FILE, config);
}
export function getMachineId() {
    if (ci.isCI) {
        return ci.name ?? "unknown-ci";
    }
    return getGlobalConfig().machineId;
}
const hook = async ({ id: command, config: { version }, error, }) => {
    if (!isEnabled()) {
        return;
    }
    const event = {
        version,
        machineId: getMachineId(),
        sessionId: crypto.randomUUID(),
        isCI: ci.isCI,
        nodeVersion: process.version,
        platform: process.platform,
        outcome: error ? "failure" : "success",
        error: error?.message,
    };
    if (isDebugMode()) {
        console.error("[Telemetry Debug] Would send event:", JSON.stringify(event, null, 2));
        return;
    }
    try {
        const client = getPostHogClient();
        client.capture({
            distinctId: event.machineId,
            event: command,
            properties: event,
        });
    }
    catch {
        // Silently ignore telemetry errors - never block CLI operation
    }
};
export default hook;
//# sourceMappingURL=telemetry.js.map