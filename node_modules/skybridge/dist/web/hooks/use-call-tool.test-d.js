import { expectTypeOf, test } from "vitest";
import { useCallTool, } from "./use-call-tool.js";
test("callTool can be called without args when ToolArgs is null", () => {
    const { callTool, callToolAsync } = useCallTool("test-tool");
    callTool();
    callTool({ onSuccess: () => { } });
    callToolAsync();
});
test("callTool requires args when ToolArgs has required properties", () => {
    const { callTool, callToolAsync } = useCallTool("test-tool");
    // @ts-expect-error - query is required
    callTool();
    callTool({ query: "test" });
    callTool({ query: "test" }, { onSuccess: () => { } });
    // @ts-expect-error - query is required
    callToolAsync();
    callToolAsync({ query: "test" });
});
test("callTool supports sideEffects with correct types", () => {
    const { callTool } = useCallTool("test-tool");
    callTool({ id: 1 }, {
        onSuccess: (data, args) => {
            expectTypeOf(data.structuredContent.result).toBeString();
            expectTypeOf(args.id).toBeNumber();
        },
        onError: (error, args) => {
            expectTypeOf(error).toBeUnknown();
            expectTypeOf(args.id).toBeNumber();
        },
        onSettled: (data, error, args) => {
            if (data) {
                expectTypeOf(data.structuredContent.result).toBeString();
            }
            expectTypeOf(error).toEqualTypeOf();
            expectTypeOf(args.id).toBeNumber();
        },
    });
});
test("callTool allows sideEffects as first arg when ToolArgs is null", () => {
    const { callTool } = useCallTool("test-tool");
    callTool({
        onSuccess: (data) => {
            expectTypeOf(data.structuredContent.value).toBeNumber();
        },
    });
});
test("callToolAsync returns correctly typed promise", () => {
    const { callToolAsync } = useCallTool("test-tool");
    const promise = callToolAsync({ name: "test" });
    expectTypeOf(promise).resolves.toHaveProperty("structuredContent");
    expectTypeOf(promise).resolves.toHaveProperty("meta");
});
test("state narrowing works correctly with status", () => {
    const result = useCallTool("test-tool");
    if (result.status === "idle") {
        expectTypeOf(result.isIdle).toEqualTypeOf();
        expectTypeOf(result.data).toEqualTypeOf();
    }
    if (result.status === "pending") {
        expectTypeOf(result.isPending).toEqualTypeOf();
        expectTypeOf(result.data).toEqualTypeOf();
    }
    if (result.status === "success") {
        expectTypeOf(result.isSuccess).toEqualTypeOf();
        expectTypeOf(result.data).not.toEqualTypeOf();
        expectTypeOf(result.data.structuredContent.data).toBeString();
    }
    if (result.status === "error") {
        expectTypeOf(result.isError).toEqualTypeOf();
        expectTypeOf(result.error).toBeUnknown();
    }
});
test("state narrowing works correctly with boolean flags", () => {
    const result = useCallTool("test-tool");
    if (result.isIdle) {
        expectTypeOf(result.status).toEqualTypeOf();
    }
    if (result.isPending) {
        expectTypeOf(result.status).toEqualTypeOf();
    }
    if (result.isSuccess) {
        expectTypeOf(result.status).toEqualTypeOf();
        expectTypeOf(result.data.structuredContent.items).toBeArray();
    }
    if (result.isError) {
        expectTypeOf(result.status).toEqualTypeOf();
    }
});
test("CallToolState type is correctly exported and usable", () => {
    const state = {};
    if (state.status === "success") {
        expectTypeOf(state.data.structuredContent.foo).toBeString();
    }
});
test("SideEffects type is correctly exported and usable", () => {
    const sideEffects = {
        onSuccess: (data, args) => {
            expectTypeOf(data.structuredContent.y).toBeString();
            expectTypeOf(args.x).toBeNumber();
        },
    };
    expectTypeOf(sideEffects).toHaveProperty("onSuccess");
});
//# sourceMappingURL=use-call-tool.test-d.js.map