const LATEST_PROTOCOL_VERSION = "2025-11-21";
var JsonRpcErrorCode;
(function (JsonRpcErrorCode) {
    JsonRpcErrorCode[JsonRpcErrorCode["ParseError"] = -32700] = "ParseError";
    JsonRpcErrorCode[JsonRpcErrorCode["InvalidRequest"] = -32600] = "InvalidRequest";
    JsonRpcErrorCode[JsonRpcErrorCode["MethodNotFound"] = -32601] = "MethodNotFound";
    JsonRpcErrorCode[JsonRpcErrorCode["InvalidParams"] = -32602] = "InvalidParams";
    JsonRpcErrorCode[JsonRpcErrorCode["InternalError"] = -32603] = "InternalError";
})(JsonRpcErrorCode || (JsonRpcErrorCode = {}));
export class McpAppBridge {
    static instance = null;
    context = {
        toolInput: null,
        toolCancelled: null,
        toolResult: null,
    };
    listeners = new Map();
    pendingRequests = new Map();
    nextId = 1;
    initialized;
    appInitializationOptions;
    requestTimeout;
    cleanupSizeObserver = null;
    constructor(options, requestTimeout = 10_000) {
        this.requestTimeout = requestTimeout;
        this.initialized = false;
        this.appInitializationOptions = {
            appInfo: options.appInfo,
            appCapabilities: {},
            protocolVersion: LATEST_PROTOCOL_VERSION,
        };
        this.init();
    }
    static getInstance(options, requestTimeout) {
        if (window.skybridge.hostType !== "mcp-app") {
            throw new Error("MCP App Bridge can only be used in the mcp-app runtime");
        }
        if (McpAppBridge.instance && (options || requestTimeout)) {
            console.warn("McpAppBridge.getInstance: options and requestTimeout ignored, instance already exists");
        }
        if (!McpAppBridge.instance) {
            const defaultOptions = {
                appInfo: { name: "skybridge-app", version: "0.0.1" },
            };
            McpAppBridge.instance = new McpAppBridge({ ...defaultOptions, ...options }, requestTimeout);
        }
        return McpAppBridge.instance;
    }
    subscribe(keyOrKeys) {
        const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];
        return (onChange) => {
            for (const key of keys) {
                this.listeners.set(key, new Set([...(this.listeners.get(key) || []), onChange]));
            }
            return () => {
                for (const key of keys) {
                    this.listeners.get(key)?.delete(onChange);
                }
            };
        };
    }
    getSnapshot(key) {
        return this.context[key];
    }
    cleanup = () => {
        window.removeEventListener("message", this.handleMessage);
        this.pendingRequests.forEach((request) => {
            clearTimeout(request.timeout);
        });
        this.pendingRequests.clear();
        this.listeners.clear();
        this.cleanupSizeObserver?.();
        this.cleanupSizeObserver = null;
    };
    static resetInstance() {
        if (McpAppBridge.instance) {
            McpAppBridge.instance.cleanup();
            McpAppBridge.instance = null;
        }
    }
    request({ method, params, }) {
        const id = this.nextId++;
        const { promise, resolve, reject } = Promise.withResolvers();
        this.pendingRequests.set(id, {
            resolve: resolve,
            reject,
            timeout: setTimeout(() => {
                reject(new Error("Request timed out"));
                this.pendingRequests.delete(id);
            }, this.requestTimeout),
        });
        window.parent.postMessage({ jsonrpc: "2.0", id, method, params }, "*");
        return promise;
    }
    emit(key) {
        this.listeners.get(key)?.forEach((listener) => {
            listener();
        });
    }
    updateContext(context) {
        this.context = { ...this.context, ...context };
        for (const key of Object.keys(context)) {
            this.emit(key);
        }
    }
    init() {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        if (typeof window === "undefined" || window.parent === window) {
            return;
        }
        window.addEventListener("message", this.handleMessage);
        this.connect();
    }
    handleMessage = (event) => {
        const data = event.data;
        if (data.jsonrpc !== "2.0") {
            return;
        }
        if ("id" in data) {
            if ("method" in data) {
                this.handleRequest(data);
                return;
            }
            this.handleResponse(data);
            return;
        }
        this.handleNotification(data);
    };
    handleResponse(response) {
        const request = this.pendingRequests.get(response.id);
        if (request) {
            clearTimeout(request.timeout);
            this.pendingRequests.delete(response.id);
            if ("error" in response) {
                request.reject(new Error(response.error.message));
                return;
            }
            request.resolve(response.result);
        }
    }
    handleNotification = (notification) => {
        switch (notification.method) {
            case "ui/notifications/host-context-changed":
                this.updateContext(notification.params);
                return;
            case "ui/notifications/tool-input":
                this.updateContext({
                    toolInput: notification.params.arguments ?? {},
                });
                return;
            case "ui/notifications/tool-result":
                this.updateContext({
                    toolResult: notification.params,
                });
                return;
            case "ui/notifications/tool-cancelled":
                this.updateContext({
                    toolCancelled: notification.params,
                });
                return;
        }
    };
    handleRequest = (request) => {
        switch (request.method) {
            case "ui/resource-teardown":
                this.cleanup();
                window.parent.postMessage({
                    jsonrpc: "2.0",
                    id: request.id,
                    result: {},
                }, "*");
                return;
            default:
                window.parent.postMessage({
                    jsonrpc: "2.0",
                    id: request.id,
                    error: {
                        code: JsonRpcErrorCode.MethodNotFound,
                        message: "Unsupported Request",
                    },
                }, "*");
        }
    };
    async connect() {
        try {
            const result = await this.request({
                method: "ui/initialize",
                params: this.appInitializationOptions,
            });
            this.updateContext(result.hostContext);
            this.notify({ method: "ui/notifications/initialized" });
            this.cleanupSizeObserver = this.setupSizeChangedNotifications();
        }
        catch (err) {
            console.error(err);
        }
    }
    notify(notification) {
        window.parent.postMessage({ jsonrpc: "2.0", ...notification }, "*");
    }
    sendSizeChanged(params) {
        this.notify({ method: "ui/notifications/size-changed", params });
    }
    /**
     * Set up automatic size change notifications using ResizeObserver.
     * Based on @modelcontextprotocol/ext-apps App.setupSizeChangedNotifications
     * @see https://github.com/modelcontextprotocol/ext-apps/blob/main/src/app.ts#L940-L989
     */
    setupSizeChangedNotifications() {
        let scheduled = false;
        let lastWidth = 0;
        let lastHeight = 0;
        const sendBodySizeChanged = () => {
            if (scheduled) {
                return;
            }
            scheduled = true;
            requestAnimationFrame(() => {
                scheduled = false;
                let width;
                let height;
                // In fullscreen mode, use viewport size since the widget should fill
                // the entire available space provided by the host.
                if (this.context.displayMode === "fullscreen") {
                    width = window.innerWidth;
                    height = window.innerHeight;
                }
                else {
                    // Use scrollWidth/scrollHeight to measure actual rendered content size.
                    // This works better than fit-content for viewport-based layouts (vw/vh)
                    // and fluid elements like maps that want to fill available space.
                    const body = document.body;
                    width = Math.ceil(body.scrollWidth);
                    height = Math.ceil(body.scrollHeight);
                }
                // Only send if size actually changed (prevents feedback loops from
                // style changes)
                if (width !== lastWidth || height !== lastHeight) {
                    lastWidth = width;
                    lastHeight = height;
                    this.sendSizeChanged({ width, height });
                }
            });
        };
        sendBodySizeChanged();
        const resizeObserver = new ResizeObserver(sendBodySizeChanged);
        resizeObserver.observe(document.documentElement);
        resizeObserver.observe(document.body);
        return () => resizeObserver.disconnect();
    }
}
//# sourceMappingURL=bridge.js.map