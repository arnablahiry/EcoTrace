import { dequal } from "dequal/lite";
import { McpAppBridge } from "./bridge.js";
export class McpAppAdaptor {
    static instance = null;
    stores;
    _widgetState = null;
    widgetStateListeners = new Set();
    _viewState = {
        mode: "inline",
    };
    viewListeners = new Set();
    constructor() {
        this.stores = this.initializeStores();
    }
    static getInstance() {
        if (!McpAppAdaptor.instance) {
            McpAppAdaptor.instance = new McpAppAdaptor();
        }
        return McpAppAdaptor.instance;
    }
    static resetInstance() {
        McpAppAdaptor.instance = null;
    }
    getHostContextStore(key) {
        return this.stores[key];
    }
    callTool = async (name, args) => {
        const bridge = McpAppBridge.getInstance();
        const response = await bridge.request({
            method: "tools/call",
            params: {
                name,
                arguments: args ?? undefined,
            },
        });
        const result = response.content
            .filter((content) => content.type === "text")
            .map(({ text }) => text)
            .join("\n");
        return {
            content: response.content,
            structuredContent: response.structuredContent ?? {},
            isError: response.isError ?? false,
            result,
            meta: response._meta ?? {},
        };
    };
    requestDisplayMode = (mode) => {
        const bridge = McpAppBridge.getInstance();
        if (mode !== "modal") {
            return bridge.request({
                method: "ui/request-display-mode",
                params: { mode },
            });
        }
        throw new Error("Modal display mode is not accessible in MCP App.");
    };
    sendFollowUpMessage = async (prompt) => {
        const bridge = McpAppBridge.getInstance();
        await bridge.request({
            method: "ui/message",
            params: {
                role: "user",
                content: [
                    {
                        type: "text",
                        text: prompt,
                    },
                ],
            },
        });
    };
    openExternal(href) {
        const bridge = McpAppBridge.getInstance();
        bridge.request({
            method: "ui/open-link",
            params: { url: href },
        });
    }
    initializeStores() {
        return {
            theme: this.createHostContextStore(["theme"], ({ theme }) => theme ?? "light"),
            locale: this.createHostContextStore(["locale"], ({ locale }) => locale ?? "en-US"),
            safeArea: this.createHostContextStore(["safeAreaInsets"], ({ safeAreaInsets }) => ({
                insets: safeAreaInsets ?? { top: 0, right: 0, bottom: 0, left: 0 },
            })),
            displayMode: this.createHostContextStore(["displayMode"], ({ displayMode }) => displayMode ?? "inline"),
            maxHeight: this.createHostContextStore(["containerDimensions"], ({ containerDimensions }) => {
                if (containerDimensions && "maxHeight" in containerDimensions) {
                    return containerDimensions.maxHeight;
                }
                return undefined;
            }),
            userAgent: this.createHostContextStore(["platform", "deviceCapabilities"], ({ platform, deviceCapabilities }) => ({
                device: {
                    type: platform === "web" ? "desktop" : (platform ?? "unknown"),
                },
                capabilities: {
                    hover: true,
                    touch: true,
                    ...deviceCapabilities,
                },
            })),
            toolInput: this.createHostContextStore(["toolInput"], ({ toolInput }) => toolInput ?? null),
            toolOutput: this.createHostContextStore(["toolResult"], ({ toolResult }) => toolResult?.structuredContent ?? null),
            toolResponseMetadata: this.createHostContextStore(["toolResult"], ({ toolResult }) => toolResult?._meta ?? null),
            view: {
                subscribe: (onChange) => {
                    this.viewListeners.add(onChange);
                    return () => {
                        this.viewListeners.delete(onChange);
                    };
                },
                getSnapshot: () => this._viewState,
            },
            widgetState: {
                subscribe: (onChange) => {
                    this.widgetStateListeners.add(onChange);
                    return () => {
                        this.widgetStateListeners.delete(onChange);
                    };
                },
                getSnapshot: () => this._widgetState,
            },
        };
    }
    setWidgetState = async (stateOrUpdater) => {
        const newState = typeof stateOrUpdater === "function"
            ? stateOrUpdater(this._widgetState)
            : stateOrUpdater;
        const bridge = McpAppBridge.getInstance();
        await bridge.request({
            method: "ui/update-model-context",
            params: {
                structuredContent: newState,
                content: [{ type: "text", text: JSON.stringify(newState) }],
            },
        });
        this._widgetState = newState;
        this.widgetStateListeners.forEach((listener) => {
            listener();
        });
    };
    /**
     * @throws File upload is not supported in MCP App.
     */
    uploadFile() {
        throw new Error("File upload is not supported in MCP App.");
    }
    /**
     * @throws File download is not supported in MCP App.
     */
    getFileDownloadUrl() {
        throw new Error("File download is not supported in MCP App.");
    }
    openModal(options) {
        this._viewState = { mode: "modal", params: options.params };
        this.viewListeners.forEach((listener) => {
            listener();
        });
    }
    closeModal() {
        this._viewState = { mode: "inline" };
        this.viewListeners.forEach((listener) => {
            listener();
        });
    }
    setOpenInAppUrl(_href) {
        throw new Error("setOpenInAppUrl is not implemented in MCP App.");
    }
    createHostContextStore(keys, computeSnapshot) {
        const bridge = McpAppBridge.getInstance();
        let cachedValue;
        return {
            subscribe: bridge.subscribe(keys),
            getSnapshot: () => {
                const context = Object.fromEntries(keys.map((k) => [k, bridge.getSnapshot(k)]));
                const newValue = computeSnapshot(context);
                if (cachedValue !== undefined && dequal(cachedValue, newValue)) {
                    return cachedValue;
                }
                cachedValue = newValue;
                return newValue;
            },
        };
    }
}
//# sourceMappingURL=adaptor.js.map