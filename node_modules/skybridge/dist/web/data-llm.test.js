import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { cleanup, render } from "@testing-library/react";
import { afterEach, beforeEach, describe, expect, it, vi, } from "vitest";
import { McpAppAdaptor, McpAppBridge } from "./bridges/mcp-app/index.js";
import { DataLLM } from "./data-llm.js";
import { getMcpAppHostPostMessageMock, MockResizeObserver, } from "./hooks/test/utils.js";
describe("DataLLM", () => {
    afterEach(() => {
        // Clean up React components BEFORE unstubbing globals
        cleanup();
        vi.unstubAllGlobals();
        vi.resetAllMocks();
    });
    describe("apps-sdk mode", () => {
        let OpenaiMock;
        beforeEach(() => {
            OpenaiMock = {
                widgetState: {},
                setWidgetState: vi.fn(),
            };
            // Use Object.defineProperty to ensure it persists
            Object.defineProperty(globalThis, "openai", {
                value: OpenaiMock,
                writable: true,
                configurable: true,
            });
            // Also set on window for browser-like environment
            if (typeof window !== "undefined") {
                Object.defineProperty(window, "openai", {
                    value: OpenaiMock,
                    writable: true,
                    configurable: true,
                });
            }
            vi.stubGlobal("openai", OpenaiMock);
            vi.stubGlobal("skybridge", { hostType: "apps-sdk" });
        });
        afterEach(() => {
            // Keep the mock available for React cleanup, but reset it
            if (typeof window !== "undefined" && window.openai) {
                window.openai.setWidgetState = vi.fn();
                window.openai.widgetState = {};
            }
        });
        it("should register a node with content and call setWidgetState", () => {
            render(_jsx(DataLLM, { content: "Test content", children: _jsx("div", { children: "Child" }) }));
            expect(OpenaiMock.setWidgetState).toHaveBeenCalled();
            const callArgs = OpenaiMock.setWidgetState.mock.calls[0]?.[0];
            expect(callArgs).toHaveProperty("__widget_context");
            expect(callArgs?.__widget_context).toContain("- Test content");
        });
        it("should preserve existing widgetState when updating context", () => {
            OpenaiMock.widgetState = { existingKey: "existingValue" };
            render(_jsx(DataLLM, { content: "Test content", children: _jsx("div", { children: "Child" }) }));
            const callArgs = OpenaiMock.setWidgetState.mock.calls[0]?.[0];
            expect(callArgs).toHaveProperty("existingKey", "existingValue");
            expect(callArgs).toHaveProperty("__widget_context");
        });
        it("should handle deeply nested DataLLM components", () => {
            render(_jsxs(DataLLM, { content: "Level 1", children: [_jsx(DataLLM, { content: "Level 2A" }), _jsx(DataLLM, { content: "Level 2B", children: _jsx(DataLLM, { content: "Level 3", children: _jsx("div", { children: "Content" }) }) })] }));
            const callArgs = OpenaiMock.setWidgetState.mock.calls[OpenaiMock.setWidgetState.mock.calls.length - 1]?.[0];
            const context = callArgs?.__widget_context;
            expect(context).toContain("- Level 1");
            expect(context).toContain("  - Level 2A");
            expect(context).toContain("  - Level 2B");
            expect(context).toContain("    - Level 3");
        });
        it("should update context when content changes", () => {
            const { rerender } = render(_jsx(DataLLM, { content: "Initial content", children: _jsx("div", { children: "Child" }) }));
            const initialCalls = OpenaiMock.setWidgetState.mock.calls.length;
            rerender(_jsx(DataLLM, { content: "Updated content", children: _jsx("div", { children: "Child" }) }));
            expect(OpenaiMock.setWidgetState.mock.calls.length).toBeGreaterThan(initialCalls);
            const lastCallArgs = OpenaiMock.setWidgetState.mock.calls[OpenaiMock.setWidgetState.mock.calls.length - 1]?.[0];
            expect(lastCallArgs?.__widget_context).toContain("- Updated content");
        });
        it("should remove node and update context when component unmounts", () => {
            const { unmount } = render(_jsx(DataLLM, { content: "Content to remove", children: _jsx("div", { children: "Child" }) }));
            const callsBeforeUnmount = OpenaiMock.setWidgetState.mock.calls.length;
            unmount();
            expect(OpenaiMock.setWidgetState.mock.calls.length).toBeGreaterThan(callsBeforeUnmount);
            const lastCallArgs = OpenaiMock.setWidgetState.mock.calls[OpenaiMock.setWidgetState.mock.calls.length - 1]?.[0];
            expect(lastCallArgs?.__widget_context).not.toContain("Content to remove");
        });
    });
    describe("mcp-app mode", () => {
        let postMessageMock;
        beforeEach(() => {
            vi.stubGlobal("skybridge", { hostType: "mcp-app" });
            vi.stubGlobal("ResizeObserver", MockResizeObserver);
            postMessageMock = getMcpAppHostPostMessageMock();
            vi.stubGlobal("parent", { postMessage: postMessageMock });
        });
        afterEach(() => {
            McpAppBridge.resetInstance();
            McpAppAdaptor.resetInstance();
        });
        it("should register a node and update widget state via adaptor", async () => {
            const adaptor = McpAppAdaptor.getInstance();
            render(_jsx(DataLLM, { content: "Test content", children: _jsx("div", { children: "Child" }) }));
            await vi.waitFor(() => {
                const widgetState = adaptor
                    .getHostContextStore("widgetState")
                    .getSnapshot();
                expect(widgetState?.__widget_context).toContain("- Test content");
            });
        });
        it("should preserve existing widget state when updating context", async () => {
            const adaptor = McpAppAdaptor.getInstance();
            await adaptor.setWidgetState({ existingKey: "existingValue" });
            render(_jsx(DataLLM, { content: "Test content", children: _jsx("div", { children: "Child" }) }));
            await vi.waitFor(() => {
                const widgetState = adaptor
                    .getHostContextStore("widgetState")
                    .getSnapshot();
                expect(widgetState?.existingKey).toBe("existingValue");
                expect(widgetState?.__widget_context).toContain("- Test content");
            });
        });
        it("should handle multiple DataLLM components sharing state through adaptor", async () => {
            const adaptor = McpAppAdaptor.getInstance();
            render(_jsxs(_Fragment, { children: [_jsx(DataLLM, { content: "First component", children: _jsx("div", { children: "First" }) }), _jsx(DataLLM, { content: "Second component", children: _jsx("div", { children: "Second" }) })] }));
            await vi.waitFor(() => {
                const widgetState = adaptor
                    .getHostContextStore("widgetState")
                    .getSnapshot();
                const context = widgetState?.__widget_context;
                expect(context).toContain("- First component");
                expect(context).toContain("- Second component");
            });
        });
        it("should call ui/update-model-context when widget state changes", async () => {
            render(_jsx(DataLLM, { content: "Test content", children: _jsx("div", { children: "Child" }) }));
            await vi.waitFor(() => {
                expect(postMessageMock).toHaveBeenCalledWith(expect.objectContaining({ method: "ui/update-model-context" }), "*");
            });
        });
    });
});
//# sourceMappingURL=data-llm.test.js.map