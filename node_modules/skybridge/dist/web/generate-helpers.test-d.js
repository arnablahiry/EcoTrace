import { expectTypeOf, test } from "vitest";
import { createInterfaceTestServer, createTestServer } from "../test/utils.js";
import { generateHelpers } from "./generate-helpers.js";
const server = createTestServer();
const interfaceServer = createInterfaceTestServer();
test("InferTools extracts the tool registry type (widgets + registerTool)", () => {
    expectTypeOf().toHaveProperty("search-voyage");
    expectTypeOf().toHaveProperty("get-trip-details");
    expectTypeOf().toHaveProperty("no-input-widget");
    expectTypeOf().toHaveProperty("calculate-price");
    expectTypeOf().toHaveProperty("inferred-output-widget");
    expectTypeOf().toHaveProperty("inferred-tool");
    expectTypeOf().toHaveProperty("widget-with-metadata");
    expectTypeOf().toHaveProperty("tool-with-metadata");
    expectTypeOf().toHaveProperty("widget-with-mixed-returns");
});
test("ToolNames returns a union of tool name literals (widgets + registerTool)", () => {
    expectTypeOf().toEqualTypeOf();
});
test("ToolInput extracts the correct input type from Zod schema", () => {
    expectTypeOf().toEqualTypeOf();
    expectTypeOf().toEqualTypeOf();
    expectTypeOf().toEqualTypeOf();
});
test("ToolOutput extracts the correct output type from callback's structuredContent", () => {
    expectTypeOf().toEqualTypeOf();
    expectTypeOf().toEqualTypeOf();
    expectTypeOf().toEqualTypeOf();
    expectTypeOf().toEqualTypeOf();
});
test("ToolOutput extracts the correct output type from callback (inferred)", () => {
    expectTypeOf().toEqualTypeOf();
    expectTypeOf().toEqualTypeOf();
});
test("generateHelpers provides autocomplete for tool names (widgets + registerTool)", () => {
    const { useCallTool } = generateHelpers();
    useCallTool("search-voyage");
    useCallTool("get-trip-details");
    useCallTool("no-input-widget");
    useCallTool("calculate-price");
    useCallTool("inferred-output-widget");
    useCallTool("inferred-tool");
    useCallTool("widget-with-metadata");
    useCallTool("tool-with-metadata");
    useCallTool("widget-with-mixed-returns");
    // @ts-expect-error - "invalid-name" is not a valid tool name
    useCallTool("invalid-name");
});
test("useCallTool returns correctly typed callTool function", () => {
    const { useCallTool } = generateHelpers();
    const { callTool } = useCallTool("search-voyage");
    callTool({ destination: "Spain" });
    callTool({ destination: "France", departureDate: "2024-06-01" });
    callTool({ destination: "Italy", maxPrice: 1000 });
    const { callTool: calculateTool } = useCallTool("calculate-price");
    calculateTool({ tripId: "123", passengers: 2 });
});
test("callTool can be called without args for tools with no required inputs", () => {
    const { useCallTool } = generateHelpers();
    const { callTool, callToolAsync } = useCallTool("no-input-widget");
    callTool();
    callTool({});
    callToolAsync();
    callToolAsync({});
});
test("callTool requires args for tools with required inputs", () => {
    const { useCallTool } = generateHelpers();
    const { callTool } = useCallTool("search-voyage");
    // @ts-expect-error - "destination" is required
    callTool();
    // @ts-expect-error - "destination" is required
    callTool({});
    // This should work
    callTool({ destination: "Spain" });
});
test("callTool supports sideEffects for tools with required inputs", () => {
    const { useCallTool } = generateHelpers();
    const { callTool } = useCallTool("search-voyage");
    callTool({ destination: "Spain" }, {
        onSuccess: (response, args) => {
            expectTypeOf(response.structuredContent.results).toBeArray();
            expectTypeOf(args.destination).toBeString();
        },
        onError: (error, args) => {
            expectTypeOf(error).toBeUnknown();
            expectTypeOf(args.destination).toBeString();
        },
        onSettled: (response, error, args) => {
            if (response) {
                expectTypeOf(response.structuredContent.totalCount).toBeNumber();
            }
            expectTypeOf(error).toBeUnknown();
            expectTypeOf(args.destination).toBeString();
        },
    });
});
test("callTool supports sideEffects for tools with no required inputs", () => {
    const { useCallTool } = generateHelpers();
    const { callTool } = useCallTool("no-input-widget");
    callTool({
        onSuccess: (response) => {
            expectTypeOf(response).toHaveProperty("structuredContent");
        },
    });
    callTool({}, {
        onSuccess: (response) => {
            expectTypeOf(response).toHaveProperty("structuredContent");
        },
    });
});
test("callToolAsync returns correctly typed promise", () => {
    const { useCallTool } = generateHelpers();
    const { callToolAsync: searchAsync } = useCallTool("search-voyage");
    const searchPromise = searchAsync({ destination: "Spain" });
    expectTypeOf(searchPromise).resolves.toHaveProperty("structuredContent");
    const { callToolAsync: noInputAsync } = useCallTool("no-input-widget");
    const noInputPromise = noInputAsync();
    expectTypeOf(noInputPromise).resolves.toHaveProperty("structuredContent");
});
test("useCallTool returns correctly typed data", () => {
    const { useCallTool } = generateHelpers();
    const { data } = useCallTool("search-voyage");
    if (data) {
        expectTypeOf(data.structuredContent).toExtend();
        expectTypeOf(data.structuredContent.results).toBeArray();
        expectTypeOf(data.structuredContent.totalCount).toBeNumber();
    }
});
test("useCallTool returns correctly typed data for callback-inferred outputs", () => {
    const { useCallTool } = generateHelpers();
    const { data: widgetData } = useCallTool("inferred-output-widget");
    if (widgetData) {
        expectTypeOf(widgetData.structuredContent).toExtend();
    }
    const { data: toolData } = useCallTool("inferred-tool");
    if (toolData) {
        expectTypeOf(toolData.structuredContent).toExtend();
    }
});
test("generateHelpers provides autocomplete for tool names in useToolInfo (widgets + registerTool)", () => {
    const { useToolInfo } = generateHelpers();
    useToolInfo();
    useToolInfo();
    useToolInfo();
    useToolInfo();
    useToolInfo();
    useToolInfo();
    useToolInfo();
    useToolInfo();
    useToolInfo();
    // @ts-expect-error - "invalid-name" is not a valid tool name
    useToolInfo();
});
test("useToolInfo infers input and output types", () => {
    const { useToolInfo } = generateHelpers();
    const toolInfo = useToolInfo();
    // Input is only available when not in idle state
    if (!(toolInfo.status === "idle")) {
        expectTypeOf(toolInfo.input).toExtend();
    }
    if (toolInfo.status === "success") {
        expectTypeOf(toolInfo.output).toExtend();
        expectTypeOf(toolInfo.output.results).toBeArray();
        expectTypeOf(toolInfo.output.totalCount).toBeNumber();
    }
});
test("ToolResponseMetadata extracts _meta type from callback", () => {
    expectTypeOf().toEqualTypeOf();
    expectTypeOf().toEqualTypeOf();
    expectTypeOf().toBeUnknown();
});
test("useToolInfo infers responseMetadata type from generateHelpers", () => {
    const { useToolInfo } = generateHelpers();
    const toolInfo = useToolInfo();
    if (toolInfo.isSuccess) {
        expectTypeOf(toolInfo.responseMetadata.requestId).toBeString();
        expectTypeOf(toolInfo.responseMetadata.timestamp).toBeNumber();
        expectTypeOf(toolInfo.responseMetadata.cached).toBeBoolean();
    }
});
test("ToolResponseMetadata extracts _meta from mixed return paths", () => {
    expectTypeOf().toEqualTypeOf();
});
test("ToolOutput extracts correct type when using interface declaration", () => {
    expectTypeOf().toHaveProperty("itemName");
    expectTypeOf().toBeString();
    expectTypeOf().toBeNumber();
});
test("ToolResponseMetadata extracts correct type when using interface declaration", () => {
    expectTypeOf().toHaveProperty("processedBy");
    expectTypeOf().toBeString();
    expectTypeOf().toBeNumber();
});
test("generateHelpers works with interface-typed server", () => {
    const { useCallTool, useToolInfo } = generateHelpers();
    const { data } = useCallTool("interface-widget");
    if (data) {
        expectTypeOf(data.structuredContent.itemName).toBeString();
        expectTypeOf(data.structuredContent.quantity).toBeNumber();
    }
    const toolInfo = useToolInfo();
    if (toolInfo.isSuccess) {
        expectTypeOf(toolInfo.output.itemName).toBeString();
        expectTypeOf(toolInfo.output.quantity).toBeNumber();
        expectTypeOf(toolInfo.responseMetadata.processedBy).toBeString();
        expectTypeOf(toolInfo.responseMetadata.version).toBeNumber();
    }
});
//# sourceMappingURL=generate-helpers.test-d.js.map